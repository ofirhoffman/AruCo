# -*- coding: utf-8 -*-
"""AruCo_ofir_hoffman.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/111E5ir4nIL0v3SySYd9VkNUFPaNmfhoV
"""

# import libs
from skimage import measure, io, img_as_ubyte, morphology, util, color
import matplotlib.pyplot as plt
from skimage.color import label2rgb, rgb2gray
import numpy as np
import pandas as pd
import cv2
import imutils

# vars
DEMO_IMAGE = '/content/drive/MyDrive/image_processing/images/AruCo_1.jpg' # a demo image for the segmentation page, if none is uploaded
favicon = '/content/drive/MyDrive/image_processing/images/marker23.png'

# main page
st.set_page_config(page_title='calculating area using AruCo - Ofir Hoffman', page_icon = favicon, layout = 'wide', initial_sidebar_state = 'auto')
st.title('calculating area using AruCo, by Ofir Hoffman')

# side bar
st.markdown(
    """
    <style>
    [data-testid="stSidebar"][aria-expanded="true"] . div:first-child{
        width: 350px
    }
    
    [data-testid="stSidebar"][aria-expanded="false"] . div:first-child{
        width: 350px
        margin-left: -350px
    }    
    </style>
    
    """,
    unsafe_allow_html=True,


)

st.sidebar.title('Segmentation Sidebar')
st.sidebar.subheader('Site Pages')

# using st.cache so streamlit runs the following function only once, and stores in chache (until changed)
@st.cache()

# take an image, and return a resized that fits our page
def image_resize(image, width=None, height=None, inter = cv2.INTER_AREA):
    dim = None
    (h,w) = image.shape[:2]
    
    if width is None and height is None:
        return image
    
    if width is None:
        r = width/float(w)
        dim = (int(w*r),height)
    
    else:
        r = width/float(w)
        dim = (width, int(h*r))
        
    # resize the image
    resized = cv2.resize(image, dim, interpolation=inter)
    
    return resized

# add dropdown to select pages on left
app_mode = st.sidebar.selectbox('Navigate',
                                  ['About App', 'calculate the area'])

# About page
if app_mode == 'About App':
    st.markdown('In this app we will calculate area using AruCo marker')
    
    
    # side bar
    st.markdown(
        """
        <style>
        [data-testid="stSidebar"][aria-expanded="true"] . div:first-child{
            width: 350px
        }

        [data-testid="stSidebar"][aria-expanded="false"] . div:first-child{
            width: 350px
            margin-left: -350px
        }    
        </style>

        """,
        unsafe_allow_html=True,


    )
    # add a image to the page

    from PIL import Image
    image = Image.open('/content/drive/MyDrive/image_processing/images/AruCo_1.jpg')

    st.image(image, caption='Sunrise by the mountains')

    # add a video to the page


    st.markdown('''
                ## About the app \n
                Hey, this web app is a great one to calculate area using AruCo marker. \n
                There are many way. \n
                Enjoy! ofir


                ''')

# Run image
if app_mode == 'Segment an Image':
    
    st.sidebar.markdown('---') # adds a devider (a line)
    
    # side bar
    st.markdown(
        """
        <style>
        [data-testid="stSidebar"][aria-expanded="true"] . div:first-child{
            width: 350px
        }

        [data-testid="stSidebar"][aria-expanded="false"] . div:first-child{
            width: 350px
            margin-left: -350px
        }    
        </style>

        """,
        unsafe_allow_html=True,


    )

    
    
    attempts_value_slider = st.sidebar.slider('Number of attempts', value = 7, min_value = 1, max_value = 10) # slider example
    st.sidebar.markdown('---') # adds a devider (a line)
    
    # read an image from the user
    img_file_from_user = st.sidebar.file_uploader("Upload an image", type=['jpg', 'jpeg', 'png'])

    parameters = cv2.aruco.DetectorParameters_create()
    aruco_dict = cv2.aruco.Dictionary_get(cv2.aruco.DICT_5X5_50)
    # assign the uplodaed image from the buffer, by reading it in
    if img_file_from_user is not None:
        image = io.imread(img_file_from_user)
        # Load Aruco detector
        # Load Aruco detector
        parameters = cv2.aruco.DetectorParameters_create()
        aruco_dict = cv2.aruco.Dictionary_get(cv2.aruco.DICT_5X5_50)
        # Get Aruco marker
        corners, _, _ = cv2.aruco.detectMarkers(img, aruco_dict, parameters=parameters)
        # Draw polygon around the marker
        int_corners = np.int0(corners)
        cv2.polylines(img, int_corners, True, (0, 255, 0), 50)
        # Aruco Area
        aruco_area = cv2.contourArea (corners[0])

        # Pixel to cm ratio
        pixel_cm_ratio = 5*5 / aruco_area# since the AruCo is 5*5 cm, so we devide 25 cm*cm by the number of pixels


        ##########################################################

        # segmentaion

        img = io.imread(img_file_from_user)
        # Convert MxNx3 image into Kx3 where K=MxN
        pixel_values  = img.reshape((-1,3))  #-1 reshape means, in this case, MxN

        #We convert the unit8 values to float as it is a requirement of the k-means method of OpenCV
        pixel_values = np.float32(pixel_values)
        # define stopping criteria
        criteria = (cv2.TERM_CRITERIA_EPS + cv2.TERM_CRITERIA_MAX_ITER, 100, 0.2)
        # number of clusters (K)
        k = 3
        attempts = 10
        _, labels, (centers) = cv2.kmeans(pixel_values, k, None, criteria, attempts, cv2.KMEANS_RANDOM_CENTERS)
        # convert back to 8 bit values
        centers = np.uint8(centers)

        # flatten the labels array
        labels = labels.flatten()
        # convert all pixels to the color of the centroids
        segmented_image = centers[labels.flatten()]
        # reshape back to the original image dimension
        segmented_image = segmented_image.reshape(img.shape)
        lst = list(np.median(centers,axis = 0))
        result_1 = [int(item) for item in lst]
        for i,center in enumerate(centers):
          if np.all(center == (result_1)):
            grass_center_index = i
            print(grass_center_index)                

        list_of_cluster_numbers_to_exclude = list(range(k)) # create a list that has the number from 0 to k-1
        list_of_cluster_numbers_to_exclude.remove(grass_center_index) # remove the cluster of grass that we want to keep, and not black out
        for cluster in list_of_cluster_numbers_to_exclude:
          masked_image[labels== cluster] = [0, 0, 0] # black all clusters except cluster 3
        # convert back to original shape
        masked_image = masked_image.reshape(img.shape)
        # detect contours in an image and grab the largest one — this contour will represent the outline/boundary of a given object in the image.
        gray = cv2.cvtColor(masked_image, cv2.COLOR_RGB2GRAY) # color to gray
        thresh = cv2.threshold(gray, 0, 255, cv2.THRESH_BINARY)[1] # threshold the gray
        cnts = cv2.findContours(thresh, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE) # find the boundaries 
        cnts = imutils.grab_contours(cnts) 
        c = max(cnts, key=cv2.contourArea)

        # draw the contours enclosing the object
        cv2.drawContours(img, cnts, -1, (0,255,0), 1) # draw the counters

        # calc number of pixels within the object and append to list
        area = cv2.contourArea(c)

        area_cm_cm = pixel_cm_ratio * area

        ##########################################################      
         else: # if no image was uploaded, then segment the demo image
        demo_image = DEMO_IMAGE
        image = io.imread(demo_image)

        # Convert MxNx3 image into Kx3 where K=MxN
        pixel_values  = img.reshape((-1,3))  #-1 reshape means, in this case, MxN

        #We convert the unit8 values to float as it is a requirement of the k-means method of OpenCV
        pixel_values = np.float32(pixel_values)
        # define stopping criteria
        criteria = (cv2.TERM_CRITERIA_EPS + cv2.TERM_CRITERIA_MAX_ITER, 100, 0.2)
        # number of clusters (K)
        k = 3
        attempts = 10
        _, labels, (centers) = cv2.kmeans(pixel_values, k, None, criteria, attempts, cv2.KMEANS_RANDOM_CENTERS)
        # convert back to 8 bit values
        centers = np.uint8(centers)

        # flatten the labels array
        labels = labels.flatten()
        # convert all pixels to the color of the centroids
        segmented_image = centers[labels.flatten()]
        # reshape back to the original image dimension
        segmented_image = segmented_image.reshape(img.shape)
        lst = list(np.median(centers,axis = 0))
        result_1 = [int(item) for item in lst]
        for i,center in enumerate(centers):
          if np.all(center == (result_1)):
            grass_center_index = i

        list_of_cluster_numbers_to_exclude = list(range(k)) # create a list that has the number from 0 to k-1
        list_of_cluster_numbers_to_exclude.remove(grass_center_index) # remove the cluster of grass that we want to keep, and not black out
        for cluster in list_of_cluster_numbers_to_exclude:
          masked_image[labels== cluster] = [0, 0, 0] # black all clusters except cluster 3
        # convert back to original shape
        masked_image = masked_image.reshape(img.shape)
        # detect contours in an image and grab the largest one — this contour will represent the outline/boundary of a given object in the image.
        gray = cv2.cvtColor(masked_image, cv2.COLOR_RGB2GRAY) # color to gray
        thresh = cv2.threshold(gray, 0, 255, cv2.THRESH_BINARY)[1] # threshold the gray
        cnts = cv2.findContours(thresh, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE) # find the boundaries 
        cnts = imutils.grab_contours(cnts) 
        c = max(cnts, key=cv2.contourArea)

        # draw the contours enclosing the object
        cv2.drawContours(img, cnts, -1, (0,255,0), 1) # draw the counters

        # calc number of pixels within the object and append to list
        area = cv2.contourArea(c)
        area_cm_cm = pixel_cm_ratio * area
 



    # display on the sidebar the uploaded image
    st.sidebar.text('Original Image')
    st.sidebar.image(image)
    
        # Display the result on the right (main frame)
    st.subheader('f'Object has an area = ', area, 'cm\N{SUPERSCRIPT TWO}')  
    st.image(masked_image, use_column_width=True)

